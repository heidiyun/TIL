# 코틀린 기초(1)
## 코틀린의 특성

### 정적 언어, 동적 언어

##### 정적 타입 지정 언어란?
	: 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있다.
	즉, 컴파일러가 타입을 검증해준다.
###### 장점 
	: 컴파일 시에 타입에 대한 정보를 결정하기 떄문에 속도가 빠르다.
	타입 에러로 인한 문제점을 초기에 발견할 수 있어 타입의 안정성이 높다.

##### 동적 타입 지정 언어란? 
	: 타입과 관계없이 모든 값을 변수에 넣을 수 있다.
	즉, 메소드나 필드 접근에 대한 검증이 실행 시점에 일어난다.
###### 장점
	- 자료형을 쓰지 않아도 되므로 정적 언어보다 코드가 짧아진다.
	-실행시까지 타입이 결정되지 않으므로 데이터 구조를 더 유연하게 생성하고 사용할 수 있다.


#### 코틀린은 무슨 언어?
	: 코틀린도 자바와 마찬가지로 정적 타입 지정언어이다. 그러나 코틀린에서는 모든 변수의 타입을 직접 명시할 필요가 없다. 
	-> 코틀린 컴파일러가 타입을 자동으로 유추할 수 있다. (타입 선언 생략 가능)
	-> 코드가 간결해지고, 생산적이다.


<자바 코드>
``` 
String s = "hello";
```
<코틀린 코드>
```
var s = "hello:
```

------------------------------
### 코틀린과 함수형 프로그래밍
##### 함수형 프로그래밍의 특징
	1. 일급 시민인 함수
		: 함수를 값처럼 사용할 수 있다.
			=> 함수를 변수에 저장가능
			=> 함수를 인자로 다른 함수에 전달 가능
			=> 함수에서 새로운 함수를 만들어 반환 가능
	2. 불변성
		: 변수가 없다.
			=> 불변 객체를 사용해 프로그램을 작성한다.
	3. 부수 효과가 없다.
		: 부수 효과란 ?
			-> 외부의 상태를 변경하는 것.
			   함수에 들어온 인자의 상태를 직접 변경하는 것.
		: 순수 함수	
			-> 동일한 인자를 주었을 때, 항상 같은 값을 리턴하는 함수.
			-> 외부의 상태를 변경하지 않는 함수.
			즉, 부수 효과가 없는 함수를 순수 함수라 한다.
		
##### 함수형 프로그래밍의 장점
	1. 간결성
		: 함수를 값처럼 활용하면 더 강력한 추상화가 가능하다.
			-> 코드 중복을 막을 수 있다.
				=> 공통부분을 함수로 뽑아내고 변하는 부분을 인자로 전달할 수 있다. (인자는 함수로 전달 가능)
	2. 다중스레드 안정성
		-> 다중스레드의 문제점 : 동기화 없이 같은 데이터에 여러 스레드가 접근할 경우 race condition이 발생한다.
		-> 불변 데이터 구조 & 순수 함수
			: 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다.
	3. 테스트가 쉽다.
		: 실행할 때 필요한 전체 환경을 구성한느 준비 코드가 따로 필요 없다.
		
#### 코틀린과 함수형 프로그래밍
##### 코틀린은 함수형 프로그래밍 기능을 지원한다.
	1) 함수를 인자로 받거나 함수가 새로운 함수를 반환할 수 있다.
```
fun hoFun(x1: Int, argFun: (Int) -> Int) {
        val result = argFun(10)
        println("x1: $x1, someFun1: $result")
    }

    fun main(args: Array<String>) {
        hoFun(10, {x -> x*x})
    }
 ```

	2) 람다 식을 지원해서 준비 코드를 작성하지 않아도 된다.
	3) 데이터 클래스는 불변적인 값 객체를 간편하게 만들수 있는 구문을 제공한다. 
		- toString, hashCode, equals, copy.. 제공
``` 
	class Person(val name: String, val age: Int) {
    override fun equals(other: Any?): Boolean {
        if (other == null) 
            return false
        if (this === other)
            return true
        if (other.javaClass != javaClass)
            return false
        
        val person = other as Person
        
        return person.name == name && person.age == age
    }
}
						
```
	위와 같이 긴 코드를 쓸 필요 없이 아래와 같이 data만 class 앞에 붙여주면 
	자동으로 생성된다. 

```	
	data class Person(val name: String, val age: Int) 

```
	4) val을 이용하여 불변의 데이터를 쉽게 정의할 수 있다. (final과 같은 수정자가 필요하지 않다.)
	5) 코틀린 표준 라이브러리는 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API를 제공한다.

### 코틀린의 장점
1. 실용성
	특정 프로그래밍 언어 스타일 사용을 강제하지 않는다.
	-> 코틀린과 여러 언어들이 혼재하여 사용이 가능하다. 
	-> 코틀린은 DSL(Domain-Specific-Language) 기능을 제공한다. 

2. 간결성
	getter/setter, 생성자 파라미터의 필드 저장 등의 보일러플레이트를 발생시키는 코드를 줄였다.
	-> 준비 코드가 적고, 코드 파악이 쉬운 구문 구조를 제공한다.

3. 안정성
	- NullPointerException에 의한 오류를 감소시켰다. 
		: null이 될 수 있는 타입을 지원한다.
			-> 컴파일 시점에 널 포인터 예외 발생 여부를 검사 할 수 있다. 
	- ClassCastException
		: 'is'로 타입검사와 캐스트를 한번에 처리 할 수 있다.

```
val s:  String? = null (null을 가질 수 있다.)
val s2: String = " " (null을 가질 수 없다.)
```

```
**자바
if(object.getClass == this.class)
	Class obj = (Class) object
	obj.fun

**코틀린
(object is Class) 
	object.fun
```

4. 상호운용성
	- 코틀린은 자바 표준 라이브러리 클래스에 의존한다. (자체 컬렉션 라이브러리 제공x)
	- 자바 코드와 코틀린 소스 파일이 혼재해도 컴파일이 가능하다.
	- 자바 메소드를 리팩토링해도 그 메소드와 관련 있는 코틀린 코드까지 제대로 변경됨.
	
