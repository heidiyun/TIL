# 9장. 제네릭스

## 9.1 제네릭 타입 파라미터
> 제네릭스를 사용하면 타입 파라미터를 받는 타입을 정의할 수 있다.
제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 궤적인 타입 인자로 치환해야 한다.

자바와 달리 코틀린은 제네릭 타입의 타입 인자를 프로그래머가 명시하거나 컴파일러가 추론할 수 있어야 한다.
```java
	List list = new ArrayList<>();
	// 자바에서 타입인자가 없는 제네릭 선언 가능.
```
### 9.1.1 제네릭 함수와 프로퍼티
> 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다.

1. 함수 호출시 타입 인자를 명시적으로 지정할 수 있다.

```java
	fun <T> List<T>.slice(indices: IntRange): List<T>

	>> val letters = ('a'..'z').toList()
	>> println(letters.slice<Char>(0..2))
```

2. 제네릭 확장 프로퍼티

```java
	val <T> List<T>.penultimate: T
		get() = this[size - 2]
```
* 일반 프로퍼티는 타입 파라미터를 가질 수 없다. 

### 9.1.2 제네릭 클래스 선언

1. 클래스나 인터페이스 뒤에 <> 기호를 넣으면 클래스를 제네릭하게 만들 수 있다.
2. 클래스 본문 안에서 타입 파라미터를 다른 일반 타입처럼 사용할 수 있다.

```java
	interface List<T> {
		operator fun get(index: Int): T // 타입 파라미터를 일반 타입처럼 사용
	}
```

3. 제네릭 클래스를 확장하는 클래스를 정의하려면 기반 타입의 제네렉 파라미터에 대해 타입 인자를 지정해야 한다.
> 구체적인 타입을 넘길 수 있고, 타입 파라미터로 받은 타입을 넘길 수도 있다.

```java
	class StringList: List<String> {
		override fun get(index: Int): String = ...}
	// 타입 인자를 String으로 지정해 List구현

	class ArrayList<T>: List<T> {
		override fun get(index: Int): T = ...
	}
	// ArrayList의 제네릭 타입 파라미터 T를 List의 타입 인자로 넘긴다.
```

4. 클래스가 자기 자신을 타입 인자로 참조할 수 있다.

```java
	interface Comparable<T> {
		fun compareTo(other: T): Int
	}

	class String: Comparable<String> {
		override fun compareTo(other: String): Int = ...
	} // String 클래스가 타입 인자로 String을 사용한다.
```

### 9.1.3 타입 파라미터 제약
> 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능

타입 파라미터에 대한 상한을 지정하면 그 제네릭 타입을 인스턴스화 할 때 사용하는 타입 인자는 반드시 그 상한 타입이거나 하위 타입이어야 한다.

```java
	fun <T: Number> List<T>.sum(): T
	// 타입 파라미터 이름 뒤에 :을 붙이고 상한 타입을 지정한다.

	/* 자바 */
	<T extends Number> T sum(List<T> lisg)
```
_타입 파라미터 T에 대한 상한을 정하면 T타입의 값을 그 상한 타입의 값으로 취급한다._
ex) 메소드 호출.


### 9.1.4 타입 파라미터를 null이 될 수 없는 타입으로 한정
> 상한을 정하지 않은 타입 파라미터는 Any?를 상한으로 지정한 것과 같다.

* 타입 파라미터의 값을 쓸 때에는 안전한 호출을 사용해야 한다.
* String?, Int?와 같은 타입도 타입 파라미터로 지정할 수 있다.

==null이 될 수 없는 타입만 타입 인자로 받으려면 <T: Any>제약을 걸어준다.==
Any가 아니더라도 ?아닌 타입을 상한으로 걸면 nullalbe 인자를 받을 수 없다.

```java
	class Processor<T: Any> {
		fun process(value: T) {
			value.hashCode() // 안전한 호출하지 않아도 됨.
		}
	}
```

## 9.2 실행 시 제네릭스의 동작 : 소거된 타입 파라미터와 실체화된 타입 파라미터
> 자바는 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다.

> 함수를 inline으로 선언하면 타입 인자가 지워지지 않게 할 수 있다.(실체화)

### 9.2.1 실행 시점의 제네릭 : 타임 검사와 캐스트
> 자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다.
 객체가 어떤 타입인지 실행 시점에는 알 수 없다.
 타입 인자에 대한 정보를 저장하지 않는다.

컴파일러가 타입 인자를 알고 올바른 타입을 보장해준다.

* 타입 소거로 인한 한계
실행 시점에 타입 인자를 검사할 수 없다.

```java
	if (value is List<String>) 
	// 실행 시점에서 String을 담은 List인지 알 수 없다.
	// 컴파일 오류가 발생한다.
``` 
즉, 실행 시점에서 어떤 값이 List인지 여부는 확실히 알 수 있지만 어떤 타입의 리스트인지는 알 수 없다.

* 타입 소거의 장점
저장해야 하는 타입 정보의 크기가 줄어들어 메모리 사용량이 줄어든다.


==코틀린에서는 타입 인자를 명시하지 않고 제네릭 타입을 사용할 수 없다.==
코틀린은 스타 프로젝션을 사용하여 어떤 인스턴스인지 확인할 수 있다.

```java
	if (value is List<*>)
```
타입 파라미터가 2개 이상이라면 모든 타입 파라미터에 * 를 포함시켜야 한다. 
(인자를 알 수 없는 제네릭 타입을 표현할 때 사용한다.)

* as, as? 연산에서 기반 클래스는 같지만 타입 인자가 달라도 캐스팅에 성공한다.

### 9.2.2 실체화한 타입 파라미터를 사용한 함수 선언
> 실행 시점에 타입 인자 정보가 지워지기 때문에 제네릭 클래스의 인스턴스를 이용하여 타입 인자를 알아낼 수 없다.

```java
	fun <T> isA(value: Any) = value is T
	// 제네릭 함수가 호출되어도 그 함수의 본문에서는 호출 시 쓰인 타입 인자를 알 수 없다.
	// 컴파일 오류 발생.
```

* **인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.**

타입 파라미터 앞에 reified 키워드를 붙이자.

```java
	inline fun <reified T> isA(value: Any) = value is T
	// 컴파일 된다.
```

* 자바에서 reified 타입 파라미터를 사용하는 inline 함수를 호출할 수 없다.
자바에서는 inline 함수를 일반 함수처럼 호출하기떄문에 타입을 실체화할 수 없다. 

* inline함수의 크기가 커지면 실체화한 타입에 의존하지 않는 부분을 별도의 알반 함수로 뽑아내는 것이 좋다.

### 9.2.3 실체화한 타입 파라미터로 클래스 참조 대신

```java
	inline fun <reified T> loadService() {
		return ServiceLoader.load(T::class.java)
	}
```

### 9.2.4 실체화한 타입 파라미터의 제약

**실체화한 타입 파라미터를 사용할 수 있는 경우**
1. 타입 검사와 캐스팅(is, !is, as, as?)
2. 코틀린 리플렉션 API
3. 코틀린 타입에 대응하는 java.lang.Class 얻기(::class.java)
4. 다른 함수를 호출할 때 타입 인자로 사용

**실체화한 타입 파라미터를 사용할 수 없는 경우**
1. 타입 파라미터 클래스의 인스턴스 생성하기
2. 타입 파라미터 클래스의 동반 객체 메소드 호출하기
3. 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
4. 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기.

