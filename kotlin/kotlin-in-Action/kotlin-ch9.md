
# 9장. 제네릭스

## 9.1 제네릭 타입 파라미터
> 제네릭스를 사용하면 타입 파라미터를 받는 타입을 정의할 수 있다.
제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 궤적인 타입 인자로 치환해야 한다.

자바와 달리 코틀린은 제네릭 타입의 타입 인자를 프로그래머가 명시하거나 컴파일러가 추론할 수 있어야 한다.
```java
	List list = new ArrayList<>();
	// 자바에서 타입인자가 없는 제네릭 선언 가능.
```
### 9.1.1 제네릭 함수와 프로퍼티
> 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다.

1. 함수 호출시 타입 인자를 명시적으로 지정할 수 있다.

```java
	fun <T> List<T>.slice(indices: IntRange): List<T>

	>> val letters = ('a'..'z').toList()
	>> println(letters.slice<Char>(0..2))
```

2. 제네릭 확장 프로퍼티

```java
	val <T> List<T>.penultimate: T
		get() = this[size - 2]
```
* 일반 프로퍼티는 타입 파라미터를 가질 수 없다. 

### 9.1.2 제네릭 클래스 선언

1. 클래스나 인터페이스 뒤에 <> 기호를 넣으면 클래스를 제네릭하게 만들 수 있다.
2. 클래스 본문 안에서 타입 파라미터를 다른 일반 타입처럼 사용할 수 있다.

```java
	interface List<T> {
		operator fun get(index: Int): T // 타입 파라미터를 일반 타입처럼 사용
	}
```

3. 제네릭 클래스를 확장하는 클래스를 정의하려면 기반 타입의 제네렉 파라미터에 대해 타입 인자를 지정해야 한다.
> 구체적인 타입을 넘길 수 있고, 타입 파라미터로 받은 타입을 넘길 수도 있다.

```java
	class StringList: List<String> {
		override fun get(index: Int): String = ...}
	// 타입 인자를 String으로 지정해 List구현

	class ArrayList<T>: List<T> {
		override fun get(index: Int): T = ...
	}
	// ArrayList의 제네릭 타입 파라미터 T를 List의 타입 인자로 넘긴다.
```

4. 클래스가 자기 자신을 타입 인자로 참조할 수 있다.

```java
	interface Comparable<T> {
		fun compareTo(other: T): Int
	}

	class String: Comparable<String> {
		override fun compareTo(other: String): Int = ...
	} // String 클래스가 타입 인자로 String을 사용한다.
```

### 9.1.3 타입 파라미터 제약
> 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능

타입 파라미터에 대한 상한을 지정하면 그 제네릭 타입을 인스턴스화 할 때 사용하는 타입 인자는 반드시 그 상한 타입이거나 하위 타입이어야 한다.

```java
	fun <T: Number> List<T>.sum(): T
	// 타입 파라미터 이름 뒤에 :을 붙이고 상한 타입을 지정한다.

	/* 자바 */
	<T extends Number> T sum(List<T> lisg)
```
_타입 파라미터 T에 대한 상한을 정하면 T타입의 값을 그 상한 타입의 값으로 취급한다._
ex) 메소드 호출.


### 9.1.4 타입 파라미터를 null이 될 수 없는 타입으로 한정
> 상한을 정하지 않은 타입 파라미터는 Any?를 상한으로 지정한 것과 같다.

* 타입 파라미터의 값을 쓸 때에는 안전한 호출을 사용해야 한다.
* String?, Int?와 같은 타입도 타입 파라미터로 지정할 수 있다.

==null이 될 수 없는 타입만 타입 인자로 받으려면 <T: Any>제약을 걸어준다.==
Any가 아니더라도 ?아닌 타입을 상한으로 걸면 nullalbe 인자를 받을 수 없다.

```java
	class Processor<T: Any> {
		fun process(value: T) {
			value.hashCode() // 안전한 호출하지 않아도 됨.
		}
	}
```

## 9.2 실행 시 제네릭스의 동작 : 소거된 타입 파라미터와 실체화된 타입 파라미터
> 자바는 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다.

> 함수를 inline으로 선언하면 타입 인자가 지워지지 않게 할 수 있다.(실체화)

### 9.2.1 실행 시점의 제네릭 : 타임 검사와 캐스트
> 자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다.
 객체가 어떤 타입인지 실행 시점에는 알 수 없다.
 타입 인자에 대한 정보를 저장하지 않는다.

컴파일러가 타입 인자를 알고 올바른 타입을 보장해준다.

* 타입 소거로 인한 한계
실행 시점에 타입 인자를 검사할 수 없다.

```java
	if (value is List<String>) 
	// 실행 시점에서 String을 담은 List인지 알 수 없다.
	// 컴파일 오류가 발생한다.
``` 
즉, 실행 시점에서 어떤 값이 List인지 여부는 확실히 알 수 있지만 어떤 타입의 리스트인지는 알 수 없다.

* 타입 소거의 장점
저장해야 하는 타입 정보의 크기가 줄어들어 메모리 사용량이 줄어든다.


==코틀린에서는 타입 인자를 명시하지 않고 제네릭 타입을 사용할 수 없다.==
코틀린은 스타 프로젝션을 사용하여 어떤 인스턴스인지 확인할 수 있다.

```java
	if (value is List<*>)
```
타입 파라미터가 2개 이상이라면 모든 타입 파라미터에 * 를 포함시켜야 한다. 
(인자를 알 수 없는 제네릭 타입을 표현할 때 사용한다.)

* as, as? 연산에서 기반 클래스는 같지만 타입 인자가 달라도 캐스팅에 성공한다.

### 9.2.2 실체화한 타입 파라미터를 사용한 함수 선언
> 실행 시점에 타입 인자 정보가 지워지기 때문에 제네릭 클래스의 인스턴스를 이용하여 타입 인자를 알아낼 수 없다.

```java
	fun <T> isA(value: Any) = value is T
	// 제네릭 함수가 호출되어도 그 함수의 본문에서는 호출 시 쓰인 타입 인자를 알 수 없다.
	// 컴파일 오류 발생.
```

* **인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.**

타입 파라미터 앞에 reified 키워드를 붙이자.

```java
	inline fun <reified T> isA(value: Any) = value is T
	// 컴파일 된다.
```

* 자바에서 reified 타입 파라미터를 사용하는 inline 함수를 호출할 수 없다.
자바에서는 inline 함수를 일반 함수처럼 호출하기떄문에 타입을 실체화할 수 없다. 

* inline함수의 크기가 커지면 실체화한 타입에 의존하지 않는 부분을 별도의 알반 함수로 뽑아내는 것이 좋다.

### 9.2.3 실체화한 타입 파라미터로 클래스 참조 대신

```java
	inline fun <reified T> loadService() {
		return ServiceLoader.load(T::class.java)
	}
```

### 9.2.4 실체화한 타입 파라미터의 제약

**실체화한 타입 파라미터를 사용할 수 있는 경우**
1. 타입 검사와 캐스팅(is, !is, as, as?)
2. 코틀린 리플렉션 API
3. 코틀린 타입에 대응하는 java.lang.Class 얻기(::class.java)
4. 다른 함수를 호출할 때 타입 인자로 사용

**실체화한 타입 파라미터를 사용할 수 없는 경우**
1. 타입 파라미터 클래스의 인스턴스 생성하기
2. 타입 파라미터 클래스의 동반 객체 메소드 호출하기
3. 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
4. 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기.

## 9.3 변성 : 제네릭과 하위 타입
> 변성 : 기반 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념.

### 9.3.1 변성이 있는 이유 : 인자를 함수에 넘기기

```java
	fun printContetns(list: List<Any>) {
		println(list.joinToString())
	}

	printontetns(listOf("abc", "bac"))
	>> abc, bac
```
String 클래스는 Any 클래스를 확장하므로 위와 같은 코드는 컴파일 된다.

```java
	fun addAnswer(list: MutableList<Any>) {
		list.add(42)
	}

	>> val strings = mutableListOf("abc", "bac")
	>> addAnswer(strings)
```
위의 코드가 컴파일 된다면 문자열 리스트에 정수를 추가할 수 있게 된다. 그러므로 위의 함수 호출문은 컴파일될 수 없다.

즉, 원소의 추가 및 변경이 있다면 기반 타입이 같아도 타입 인자가 다른 파라미터를 받을 수 없다.

### 9.3.2 클래스, 타입, 하위 타입
> 변수의 타입이 그 변수에 담을 수 있는 값의 집합을 지정한다.

_클래스 vs 타입_
일반 클래스에서는 클래스 이름을 바로 타입으로 쓸 수 있다.
제네릭 클래스를 타입으로 쓰려면 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.

**하위타입**: A타입이 필요한 모든 장소에 B타입의 값을 넣어도 아무 문제가 없다면 타입B는 타입A의 하위 타입이다.
(하위 타입은 하위 클래스와 같다. 단, 널이 될 수 있는 타입은 하위 타입과 하위 클래스가 같지 않다.)

즉, 모든 타입이 자기 자신의 하위 타입이다.

함수 인자 전달 시, 컴파일러는 하위 타입 검사를 매번 수행한다.
특정 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입할 수 있다.

**제네릭 타입을 인스턴스화 할때 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않으면 제네릭 타입을 무공변이라고 한다.**
반대의 개념이 공변이다.
(자바에서는 모든 클래스가 무공변이다.)

### 9.3.3 공변성 : 하위 타입 관계를 유지

```java
	interface Producer<out T> {
		fun produce(): T
	}
```
코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 앞에 'out'을 붙인다.
* 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다.

_단점_
1. 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다.
-> 타입 안전성을 보장하기 위해 공변적 파라미터는 항상 out위치에만 있어야 한다.
-> 클래스가 T타입의 값을 생산할 수 있지만 T타입의 값을 소비할 수 없다.

T가 함수의 반환 타입에 쓰인다면 T는 아웃 위치에 있다.
-> T타입의 값을 생산한다.
T가 함수의 파라미터 타입에 쓰인다면 T는 인 위치에 있다.
-> T타입의 값을 소비한다.

클래스 타입 파라미터 T앞에 out키워드를 붙이면 클래스 안에서 T를 사용하면 메소드가 아웃 위치에만 T를 사용하게 허용한다.
(생성자 파라미터는 인, 아웃 어느쪽도 아니다. out T여도 생성자 파라미터 안에 쓸 수 있다.)

val은 아웃 위치, var은 아웃과 인 위치 모두에 해당한다.

변성은 외부에서 볼 수 있는 클래스 API에만 적용할 수 있다.

### 9.3.4 반공변성 : 뒤집힌 하위 타입 관계

반공변성 : 타입 B가 타입A의 하위 타입인 경우 Consumer< A > 가 
Consumer< B >의 하위 타입인 관계가 성립하면 제네릭 클래스 Consumer<T>는 타입 인자 T에 대해 반공변이다.

```java
	interface Comparator<in T> {
		fun compare(e1: T, e2: T): Int {...}
	}
```
타입 파라미터 앞에 'in'을 붙이면 T타입의 값을 소비할 수만 있다.

### 9.3.5 사용 지점 변성 : 타입이 언급되는 지점에서 변성 지정
> 자바에서는 타입 파라미터가 있는 타입을 사용할 때마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시해야 한다.

타입 프로젝션 : in out변경자를 붙여서 제약을 가한다.


### 9.3.6 스타 프로젝션 : 타입 인자 대신 * 사용
> 제네릭 타입 인자 정보가 없음을 표현하기 위해 스타 프로젝션을 사용한다.

1. MutableList< * >는 MutableList<Any?>와 같지 않다. MutableList<Any?>는 모든 타입의 원소를 담을 수 있다. MutableList< * >는 어떤 정해진 구체적인 원소만을 담는 리스트지만 그 원소 타입을 정확히 모른다.

MutableList< * >를 파라미터로 받는 경우 정확한 타입을 모를경우 값을 넣을 수는 없지만 Any?타입으로 값을 꺼내올 수 는 있다. 

2. 타입 인자 정보가 중요하지 않을 경우 스타 프로젝션 구문을 사용할 수 있다.

스타 프로젝션을 사용할 때는 값을 만들어내는 메소드만 호출할 수 있다.
