## 2.2 클래스와 프로퍼티

- 필드가 늘어날 수록 생성자에서 파라미터 대입문의 길이가 길어진다.

- 코드가 없이 데이터만 저장하는 클래스를 값 객체(value object)라고 한다.

### 2.2.1 프로퍼티

#### 클래스의 목적

	:데이터 캡슐화

	-> 멤버 필드 보통 private

	=> 데이터 접근을 위해 접근자 메소드를 제공한다.

#### 프로퍼티란?
> 필드와 접근자를 통칭하는 말.

##### kotlin에서의 프로퍼티 
	: 언어의 기본 기능으로 프로퍼티를 제공한다.
	   자바의 필드와 접근자 메소드를 대체한다.
	   (따로 필드를 생성하고 접근자 메소드를 만들지 않아도 된다.)

-  val : 읽기 전용 프로퍼티
	(비공개 필드와 공개 getter를 만들어낸다.)

- var : 변경가능한 프로퍼티
	(비공개 필드와 공개 getter/setter를 만들어낸다.)

* backing field
	```
	 프로퍼티의 값을 저장하기 위한 필드.
	* 식별자 field를 제공한다.
		* field 식별자를 통해 접근할 수 있는 automatic backing field를 제공한다.
			=> 프로퍼티의 accessor(getter/setter)에서만 사용가능하다.

	* 생성조건
		*   accessor중 1개라도 기본 구현을 사용하는 경우
		* custom accessor에서 field 식별자를 참조하는 경우

### 2.2.2 커스텀 접근자
>클라이언트가 프로퍼티에 접근할 때마다 프로퍼티 값을 매번 다시 계산한다.
	( 프로퍼티의 자체 값을 저장하는 필드가 없다.)

![property](/assets/커스텀접근자.png)

'블록문을  제거한  코드'
	: 이러한  코드는 setter에서는  적용  불가능하다.

![property](/assets/커스텀접근자2.png)

### 2.2.3 코틀린  소스코드  구조 : 디렉토리와  패키지

-   모든  코틀린  파일의  맨  앞에  package문을  넣을  수  있다.

		: 같은  패키지에  있다면  다른  파일에서  정의한  선언을  직접  사용  할  수  있다.
		다른  패키지에  있다면  import를  통해  선언을  불러와야  한다.

![property](/assets/패키지.png)

![property](/assets/패키지2.png)
-   자바에서는  패키지  구조와  일치하는  디렉터리  계층  구조를  만들고, 클래스의  소스코드를  해당  패키지와  디렉토리에  위치시켜야  한다.
	But, 코틀린은  패키지가  다른  여러  클래스를  한  파일에  위치  시켜도  된다.

## 2.3 선택  표현과  처리: enum과  when

### 2.3.1. enum  클래스  정의

-   enum은  soft keyword (class 앞에서만  기능을  하고, 다른  곳에서는  이름으로  사용할  수  있다.)
-   enum class도  프로퍼티와  메소드를  가질  수  있다.
![property](/assets/enum.png)

### 2.3.2 when으로  enum 클래스  다루기

	-   when (expression)
	-   자바의  switch문을  대체하는  구문.
	-   각  분기의  끝에  break;  구문을  넣지  않아도  된다.
	-   한  분기  안에서  여러  값을  매치하려면  값  사이를 (,)로  분리한다.

		![property](/assets/when.png)

		![property](/assets/when2.png)
		
	-   그  외의  모든  값은  else로  처리한다.

		![property](/assets/when3.png)

### 2.3.3 when과  임의의  객체를  함께  사용
>자바의  switch문은  분기  조건으로  상수만을  허용했다면, 코틀린의  when은  분기  조건으로  임의의  객체를  허용한다.

### 2.3.4. 인자가  없는  when 사용
> 각  분기의  조건이  불리언  결과를  계산하는  식이어야  하므로, 가독성이  떨어진다.

### 2.3.5. 스마트  캐스트 :  타입  검사와  타입  캐스트를  조합
	- 유저가  명시적으로  캐스팅해주지  않아도  컴파일러가  캐스팅을  해준다.
	-   불필요한  코드의  중복을  줄일  수  있다.

		![property](/assets/smartcast.png)
	-   Is를  사용할  수  있는  경우
	-   프로퍼티에  대한  스마트  캐스트를  사용한다면
	-   프로퍼티는  반드시  val이어야  한다.
	-   커스텀  접근자를  사용한  것이  아니어야  한다.

	// 86page, 스마트  캐스트는  is로  변수에  든  값의  타입을  검사한  다음에  그  값이  바뀔  수  없는  경우에만  작동한다.

	-> 있는  경우  아닌가?

	-   명시적  타입  캐스팅은  'as' 키워드를  사용한다.

### 2.3.6 리팩토링 : if를 when으로  변경
  1. 코틀린에서의  if문은  값을  만들어  내는  식이므로, 'return'  키워드를  생략할  수  있다.

  2. 블록의  마지막  식이  그  분기의  결과  값이다.

  3.  2.3.5의  if문을  when으로  변경한  코드
		> 스마트  캐스팅이  일어남.
		![property](/assets/if.png)