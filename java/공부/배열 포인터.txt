포인터 변수
: 다른 함수에서 변수의 값을 변경하기 위해서
: call by reference

주소를 저장하기 위한 타입 - 포인터 타입
	: 모든 포인터 타입 변수의 크기는 8 바이트 이다.

포인터 변수는 추가적인 연산을 허용한다.
	: 자신이 가지고 있는 주소값을 참조할 수 있는 연산을 제공한다.
	: * 참조 연산자

배열이름은 배열의 첫번째 원소의 시작 주소를 말한다.

arr -> int arr[] -> &arr[0] -> &int[3] -> int*

int arr[2][3];
 arr -> &arr[0] -> int[3] *
&arr -> &int[3] -> int[3] * 

c언어는 1차원 배열만 존재한다.

포인터 + 상수 : 주소값 + 포인터 대상체 타입 크기 * 상수

*(*(arr+0)) = *

int (*p)[3] -> int [3]짜리 배열을 통째로 가르킨다.
int *p  -> int 타입 첫번째 주소를... 가르킨다.

문자열이 rodata(read only)수정 불가)에 저장된다. 
같은 문자열을 입력할 때, 같은 주소값을 가르키게 된다..?
char [] -> 전역변수영역에 복사 (함수 안을 벗어난다.)
char [] -> 지역변수 영역에 복사(함수 안에)

세그멘테이션 오류 : 비정상종류.. 메모리 문제

전역변수 : 데이터영역에 저장 , 초기화 0, 프로그램의 용량이 늘어난다(초기화 된 전역변수를 사용했을 때).
지역변수 : 스택 7f, 초기화 쓰레기값

포인터 : 배열의 시작 원소 혹은 그 원소

int (*p)[3] -> 배열 전체의 주소...(일반 변수를 선언한다고 생각하고 쓰기)
int *p -> 배열의 첫 원소의 주소....(그냥 배열 전체를 보냈다고 생각하고 쓰기)



포인터 변수 초기화 안하고
int * ptr;

*ptr
 ptr
&ptr
의 값.


int (*p)[3]
int *p



p[0] -> *(p+0)
