# 복사 정책
1. Value copy (얕은 복사)
* 장점
속도가 빠르고 메모리를 값 복사보다 적게 쓴다.
* 단점
객체의 파괴 시점을 결정할 수 없다.

2. Reference copy (깊은 복사)
* 장점 
객체의 파괴 시점을 결정할 필요가 없다.
원 참조와 복사 참조가 각각 다른 메모리를 참조하기 때문에 서로 영향을 받지않는다.
* 단점
데이터의 크기가 클 수록 속도가 느려지고, 메모리 소모가 커진다.

## Referencing Counting (참조 계수)
> 객체의 수명관리를 위해서 해당 객체를 가르키고 있는 레퍼런스가 몇 개 인지 알려준다.  

### 문제점
1. 순환 참조일 경우 메모리 누수가 발생할 수 있다. (무조건적으로 발생하는 것은 아니다.)
2. 참조계수의 증감이 발생할 때, lock & unlock이 필요하다. (깊은 복사보다 느려질 수 있다.)

### 참조계수를 관리하는 2가지 방법
1. GC  (Garbage Collection) : Java, Go, C#, Javascript
런타임에 프로그램이 객체의 수거를 담당한다.
참조계수가 0인 객체를 수거한다.
GC 가 작동하면 finalize 메소드가 실행된다.

* 장점 : 런타임에 GC 가 판단해서 객체를 수거하므로 유연하게 동작한다.
* 단점 : GC 가 동작하는 동안 프로그램이 돌아가지 않으므로, 성능이 저하된다.

2. ARC : Objective-c, Swift
컴파일 타임에 객체의 참조 계수를 관리하는 코드를 삽입한다.

* 장점 : 프로그램이 빠르게 동작한다.
* 단점  
1. 제대로 된 코드를 작성하지 않으면, 정상적으로 객체의 메모리가 수거되지 않는다.
		-> 댕글링 포인터가 발생하여 프로그램이 죽을 수 있다.
		-> 댕글링 포인터 :  이미 해제된 메모리 영역을 가르키는 레퍼런스
2. 컴파일이 얻을 수 있는 정보는 한정적이다.

## 주의할 점
### 비메모리 자원 해제
> 메모리 자원 : 객체  
> 비메모리 자원 : 자바가 제공하는 메모리가 아닌, 운영체제가 제공하는서비스를 이용하는 자원   
> ex) File, Thread, Process  

비메모리 자원을 사용한 후에는 반드시 명시적인 종료 메소드를 통해 해지해야 한다.
-> 해지하지 않을 경우, 메모리 누수가 발생할 수도 있다.
-> 자바 클래스 라이브러리는 비메모리 자원에 대한 파괴를 finalize를 통해서 제공한다.*

* 문제점 
finalize의 호출 시점이 명확하지 않으며, 호출이 보장되지 않는다.
즉, 메모리 누수 발생가능성을 증가시킨다.
**그러므로 반드시 비메모리 자원을 명시적으로 해지시켜 주자.**

### Strong,Weak, Soft Reference
1. Strong Reference : 객체를 가르키고 있는 레퍼런스가 하나라도 있다면, GC가 수거해 가지 않는다.
참조계수가 증가.
2. Weak Reference : out of memory에 가까워지면 객체가 수거된다.
참조 계수에 포함 x
3. Soft Reference : GC가 수행되면 무조건 객체가 수거된다.
참조 계수에 포함 x

#### Weak or Soft Reference 사용방법
위의 두가지 참조를 사용하여 연산을 할 경우, 객체가 유효한지 판단하고, 유요하다면 강한 참조로 바꿔준다.
그리고 referencing counting의 값을 증가시킨다.



#java